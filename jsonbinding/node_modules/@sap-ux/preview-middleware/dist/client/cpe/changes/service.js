'use strict';
sap.ui.define([
    'open/ux/preview/client/thirdparty/@sap-ux-private/control-property-editor-common',
    './flex-change',
    'sap/base/Log',
    '../rta-service',
    'sap/ui/core/util/reflection/JsControlTreeModifier',
    '../../utils/error',
    '../../utils/version',
    'sap/m/MessageToast',
    '../../i18n',
    '../../utils/core',
    '../../utils/fe-v4'
], function (___sap_ux_private_control_property_editor_common, ___flex_change, Log, ___rta_service, JsControlTreeModifier, ____utils_error, ____utils_version, MessageToast, ____i18n, ____utils_core, ____utils_fe_v4) {
    'use strict';
    function __ui5_require_async(path) {
        return new Promise(function (resolve, reject) {
            sap.ui.require([path], function (module) {
                if (!(module && module.__esModule)) {
                    module = module === null || !(typeof module === 'object' && path.endsWith('/library')) ? { default: module } : module;
                    Object.defineProperty(module, '__esModule', { value: true });
                }
                resolve(module);
            }, function (err) {
                reject(err);
            });
        });
    }
    const changeProperty = ___sap_ux_private_control_property_editor_common['changeProperty'];
    const changeStackModified = ___sap_ux_private_control_property_editor_common['changeStackModified'];
    const deletePropertyChanges = ___sap_ux_private_control_property_editor_common['deletePropertyChanges'];
    const propertyChangeFailed = ___sap_ux_private_control_property_editor_common['propertyChangeFailed'];
    const FlexChangesEndPoints = ___sap_ux_private_control_property_editor_common['FlexChangesEndPoints'];
    const reloadApplication = ___sap_ux_private_control_property_editor_common['reloadApplication'];
    const setApplicationRequiresReload = ___sap_ux_private_control_property_editor_common['setApplicationRequiresReload'];
    const save = ___sap_ux_private_control_property_editor_common['save'];
    const CONFIGURATION_CHANGE_KIND = ___sap_ux_private_control_property_editor_common['CONFIGURATION_CHANGE_KIND'];
    const PropertyType = ___sap_ux_private_control_property_editor_common['PropertyType'];
    const PENDING_CHANGE_TYPE = ___sap_ux_private_control_property_editor_common['PENDING_CHANGE_TYPE'];
    const PROPERTY_CHANGE_KIND = ___sap_ux_private_control_property_editor_common['PROPERTY_CHANGE_KIND'];
    const UNKNOWN_CHANGE_KIND = ___sap_ux_private_control_property_editor_common['UNKNOWN_CHANGE_KIND'];
    const applyChange = ___flex_change['applyChange'];
    const modeAndStackChangeHandler = ___rta_service['modeAndStackChangeHandler'];
    const getError = ____utils_error['getError'];
    const isLowerThanMinimalUi5Version = ____utils_version['isLowerThanMinimalUi5Version'];
    const getUi5Version = ____utils_version['getUi5Version'];
    const getTextBundle = ____i18n['getTextBundle'];
    const getControlById = ____utils_core['getControlById'];
    const isA = ____utils_core['isA'];
    const getConfigMapControlIdMap = ____utils_fe_v4['getConfigMapControlIdMap'];
    const TITLE_MAP = { appdescr_app_addAnnotationsToOData: 'Add New Annotation File' };
    const STACK_CHANGE_EVENT = 'STACK_CHANGED';
    const PROPERTY_CHANGE = 'propertyChange';
    const PROPERTY_BINDING_CHANGE = 'propertyBindingChange';
    const MANIFEST_V4_CHANGE = 'appdescr_fe_changePageConfiguration';
    function assertProperties(properties, target) {
        for (const property of properties) {
            const value = target[property];
            if (value === null || value === undefined) {
                throw new Error(`Invalid change, missing ${ property } in the change file`);
            }
        }
    }
    function assertChange(change) {
        assertProperties([
            'fileName',
            'selector',
            'content',
            'creation'
        ], change);
        assertProperties(['id'], change.selector);
        assertProperties(['property'], change.content);
    }
    function assertManifestChange(change) {
        assertProperties([
            'fileName',
            'content',
            'creation'
        ], change);
        assertProperties([
            'page',
            'entityPropertyChange'
        ], change.content);
        assertProperties([
            'propertyPath',
            'operation',
            'propertyValue'
        ], change.content.entityPropertyChange);
    }
    function modifyRTAErrorMessage(errorMessage, id, type) {
        return errorMessage.replace('Error: Applying property changes failed:', '').replace(`${ type }#${ id }`, '');
    }
    function getCompactV4ConfigPath(propertyPathSeg) {
        return propertyPathSeg.join('/').replace(/^controlConfiguration\/(?:([^/]+\/))?@[^/]+\.v1\./, '$1');
    }
    class ChangeService extends EventTarget {
        savedChanges = [];
        changesRequiringReload = 0;
        pendingChanges = [];
        changedFiles = {};
        eventStack = [];
        pendingConfigChangeMap = new Map();
        configPropertyControlIdMap = new Map();
        constructor(options) {
            super();
            this.options = options;
        }
        async init(sendAction, subscribe) {
            this.sendAction = sendAction;
            subscribe(async action => {
                if (changeProperty.match(action)) {
                    try {
                        await applyChange(this.options, action.payload);
                    } catch (exception) {
                        let name = '';
                        const id = action.payload.controlId || '';
                        const control = sap.ui.getCore().byId(id);
                        if (control) {
                            name = control.getMetadata().getName();
                        }
                        const error = getError(exception);
                        const modifiedMessage = modifyRTAErrorMessage(error.toString(), id, name);
                        const errorMessage = modifiedMessage || `RTA Exception applying expression "${ action.payload.value }"`;
                        const propertyChangeFailedAction = propertyChangeFailed({
                            ...action.payload,
                            errorMessage
                        });
                        sendAction(propertyChangeFailedAction);
                    }
                } else if (deletePropertyChanges.match(action)) {
                    await this.deleteChange(action.payload.controlId, action.payload.propertyName, action.payload.fileName);
                } else if (reloadApplication.match(action)) {
                    this.sendAction(setApplicationRequiresReload(false));
                } else if (save.match(action)) {
                    this.changesRequiringReload = 0;
                    this.sendAction(setApplicationRequiresReload(false));
                }
            });
            await this.fetchSavedChanges();
            this.updateStack();
            this.options.rta.attachUndoRedoStackModified(this.createOnStackChangeHandler());
        }
        updateStack() {
            this.sendAction(changeStackModified({
                saved: this.savedChanges ?? [],
                pending: this.pendingChanges ?? []
            }));
        }
        getSavedConfigurationChange(change) {
            assertManifestChange(change);
            if ([change.content.entityPropertyChange.propertyValue].every(item => item === undefined || item === null)) {
                throw new Error('Invalid change, missing property value on change file');
            }
            const propertyPathSegments = change.content.entityPropertyChange.propertyPath.split('/');
            const propertyName = propertyPathSegments.pop();
            const configMapKey = getConfigMapControlIdMap(change.content.page, propertyPathSegments);
            const controlIds = this.configPropertyControlIdMap?.get(configMapKey) || [];
            return {
                type: 'saved',
                kind: 'configuration',
                fileName: change.fileName,
                controlIds,
                propertyPath: getCompactV4ConfigPath(propertyPathSegments) || change.content.page,
                propertyName: propertyName ?? '',
                value: change.content.entityPropertyChange.propertyValue,
                timestamp: new Date(change.creation).getTime()
            };
        }
        async fetchSavedChanges() {
            this.changedFiles = {};
            const savedChangesResponse = await fetch(FlexChangesEndPoints.changes + `?_=${ Date.now() }`);
            const savedChanges = await savedChangesResponse.json();
            const changes = (await Promise.all(Object.keys(savedChanges ?? {}).map(async key => {
                const change = savedChanges[key];
                let selectorId;
                try {
                    if (change.changeType === MANIFEST_V4_CHANGE) {
                        return this.getSavedConfigurationChange(change);
                    } else {
                        const flexObject = await this.getFlexObject(change);
                        selectorId = await this.getControlIdByChange(flexObject);
                        assertChange(change);
                        if ([
                                change.content.newValue,
                                change.content.newBinding
                            ].every(item => item === undefined || item === null)) {
                            throw new Error('Invalid change, missing new value in the change file');
                        }
                        if (change.changeType !== 'propertyChange' && change.changeType !== 'propertyBindingChange') {
                            throw new Error('Unknown Change Type');
                        }
                        this.changedFiles[change.fileName] = change;
                        return {
                            type: 'saved',
                            kind: 'property',
                            fileName: change.fileName,
                            controlId: selectorId,
                            propertyName: change.content.property,
                            value: change.content.newValue ?? change.content.newBinding,
                            timestamp: new Date(change.creation).getTime(),
                            controlName: change.selector.type ? change.selector.type.split('.').pop() : '',
                            changeType: change.changeType
                        };
                    }
                } catch (error) {
                    const title = TITLE_MAP[change.changeType] ?? '';
                    if (change.fileName) {
                        this.changedFiles[change.fileName] = change;
                        const unknownChange = {
                            type: 'saved',
                            kind: 'unknown',
                            changeType: change.changeType,
                            fileName: change.fileName,
                            timestamp: new Date(change.creation).getTime(),
                            ...title && { title }
                        };
                        if (change.creation) {
                            unknownChange.timestamp = new Date(change.creation).getTime();
                        }
                        if (selectorId) {
                            const controlChange = {
                                ...unknownChange,
                                kind: 'control',
                                controlId: selectorId
                            };
                            return controlChange;
                        }
                        return unknownChange;
                    }
                    return undefined;
                }
            }))).filter(change => !!change).sort((a, b) => b.timestamp - a.timestamp);
            this.savedChanges = changes;
        }
        async deleteChange(controlId, propertyName, fileName) {
            const filesToDelete = this.savedChanges.filter(change => {
                if (fileName) {
                    return fileName === change.fileName;
                }
                if (change.kind === 'property') {
                    return change.controlId === controlId && change.propertyName === propertyName;
                }
                if (change.kind === 'control') {
                    return change.controlId === controlId;
                }
                return false;
            }).map(change => fetch(FlexChangesEndPoints.changes, {
                method: 'DELETE',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ fileName: change.fileName })
            }));
            await Promise.all(filesToDelete).catch(error => Log.error(getError(error).message));
            await this.fetchSavedChanges();
            this.updateStack();
        }
        createOnStackChangeHandler() {
            const handleStackChange = modeAndStackChangeHandler(this.sendAction, this.options.rta);
            return async event => {
                const pendingChanges = [];
                this.eventStack.push(event);
                const stack = this.options.rta.getCommandStack();
                const allCommands = stack.getCommands();
                const executedCommands = stack.getAllExecutedCommands();
                const allCommandsFlattened = allCommands.flatMap(command => typeof command.getCommands === 'function' ? command.getCommands() : [command]);
                const activeCommandCount = allCommandsFlattened.length - executedCommands.length;
                this.pendingConfigChangeMap = new Map();
                let i = 0;
                for (const command of allCommands) {
                    try {
                        if (typeof command.getCommands === 'function') {
                            const subCommands = command.getCommands();
                            for (const subCommand of subCommands) {
                                await this.handleCommand(subCommand, activeCommandCount, i, pendingChanges);
                                i++;
                            }
                        } else {
                            await this.handleCommand(command, activeCommandCount, i, pendingChanges);
                            i++;
                        }
                    } catch (error) {
                        Log.error('CPE: Change creation Failed', getError(error));
                    }
                }
                const resourceBundle = await getTextBundle();
                const eventIndex = this.eventStack.indexOf(event);
                if (this.eventStack.length - 1 === eventIndex) {
                    this.pendingChanges = pendingChanges.filter(change => !!change);
                    const changesRequiringReload = this.pendingChanges.reduce((sum, change) => change.kind === CONFIGURATION_CHANGE_KIND || change.changeType === 'appdescr_ui_generic_app_changePageConfiguration' || change.changeType === 'appdescr_app_addAnnotationsToOData' ? sum + 1 : sum, 0);
                    if (changesRequiringReload > this.changesRequiringReload) {
                        MessageToast.show(resourceBundle.getText('CPE_CHANGES_VISIBLE_AFTER_SAVE_AND_RELOAD_MESSAGE'), { duration: 8000 });
                        this.sendAction(setApplicationRequiresReload(changesRequiringReload > 0));
                    }
                    this.changesRequiringReload = changesRequiringReload;
                }
                this.eventStack.splice(eventIndex, 1);
                if (Array.isArray(allCommands) && allCommands.length === 0) {
                    this.pendingChanges = [];
                    this.pendingConfigChangeMap = new Map();
                    await this.fetchSavedChanges();
                }
                const configurationChanges = this.pendingChanges?.filter(item => item.kind === 'configuration');
                if (configurationChanges.length) {
                    const stackChangeEvent = new CustomEvent(STACK_CHANGE_EVENT, {
                        detail: {
                            controls: configurationChanges.reduce((acc, item) => {
                                const controls = (item.controlIds || []).map(id => {
                                    return getControlById(id);
                                }).filter(ui5Element => isA('sap.ui.core.Element', ui5Element));
                                acc.push(...controls);
                                return acc;
                            }, [])
                        }
                    });
                    this.dispatchEvent(stackChangeEvent);
                }
                this.updateStack();
                handleStackChange();
            };
        }
        getConfigurationPropertyValue(controlId, propertyName) {
            const pendingChanges = this.pendingConfigChangeMap?.get(controlId);
            return (pendingChanges || []).find(item => item.isActive && item.propertyName === propertyName)?.value;
        }
        async updateConfigurationProps(configPropertyControlIdMap) {
            this.configPropertyControlIdMap = configPropertyControlIdMap;
            await this.fetchSavedChanges();
            this.updateStack();
        }
        async handleCommand(command, inactiveCommandCount, index, pendingChanges) {
            const pendingChange = await this.prepareChangeType(command, inactiveCommandCount, index);
            if (pendingChange) {
                pendingChanges.push(pendingChange);
            }
        }
        prepareV4ConfigurationChange(command, value, fileName, index, inactiveCommandCount) {
            const {entityPropertyChange, page} = command.getProperty('parameters');
            const controlId = this.getCommandSelectorId(command) ?? '';
            const propertyPathSegments = entityPropertyChange.propertyPath.split('/');
            const propName = propertyPathSegments.pop();
            const key = getConfigMapControlIdMap(page, propertyPathSegments);
            const isActive = index >= inactiveCommandCount;
            const controlIds = this.configPropertyControlIdMap?.get(key) || [controlId];
            const result = {
                type: PENDING_CHANGE_TYPE,
                kind: CONFIGURATION_CHANGE_KIND,
                controlIds,
                propertyPath: getCompactV4ConfigPath(propertyPathSegments) || page,
                propertyName: propName,
                isActive,
                value,
                fileName
            };
            for (const id of result.controlIds) {
                if (!this.pendingConfigChangeMap.get(id)) {
                    this.pendingConfigChangeMap.set(id, []);
                }
                const pendingChanges = this.pendingConfigChangeMap.get(id);
                pendingChanges?.push(result);
            }
            return result;
        }
        prepareV2ConfigurationChange(command, fileName, index, inactiveCommandCount) {
            const {entityPropertyChange, page} = command.getProperty('parameters');
            const propertyPathSegments = entityPropertyChange.propertyPath.split('/');
            const propertyName = Object.keys(entityPropertyChange.propertyValue)?.[0] ?? propertyPathSegments[propertyPathSegments.length - 1];
            const propertyValue = entityPropertyChange.propertyValue?.[propertyName] ?? entityPropertyChange.propertyValue;
            const controlId = this.getCommandSelectorId(command) ?? '';
            const key = getConfigMapControlIdMap(page, propertyPathSegments);
            const isActive = index >= inactiveCommandCount;
            const controlIds = this.configPropertyControlIdMap?.get(key) || [controlId];
            const result = {
                type: PENDING_CHANGE_TYPE,
                kind: CONFIGURATION_CHANGE_KIND,
                controlIds,
                propertyPath: getCompactV4ConfigPath(propertyPathSegments) || page,
                propertyName,
                isActive,
                value: propertyValue,
                fileName
            };
            for (const id of result.controlIds) {
                if (!this.pendingConfigChangeMap.get(id)) {
                    this.pendingConfigChangeMap.set(id, []);
                }
                const pendingChanges = this.pendingConfigChangeMap.get(id);
                pendingChanges?.push(result);
            }
            return result;
        }
        async prepareChangeType(command, inactiveCommandCount, index) {
            const change = command?.getPreparedChange?.();
            const selectorId = typeof change?.getSelector === 'function' ? await this.getControlIdByChange(change) : this.getCommandSelectorId(command);
            const changeType = this.getCommandChangeType(command);
            if (!changeType) {
                return undefined;
            }
            const {fileName} = change.getDefinition ? change.getDefinition() : change.getJson();
            if ((changeType === 'propertyChange' || changeType === 'propertyBindingChange') && selectorId) {
                let value = '';
                switch (changeType) {
                case 'propertyChange':
                    value = command.getProperty('newValue');
                    break;
                case 'propertyBindingChange':
                    value = command.getProperty('newBinding');
                    break;
                }
                return {
                    type: PENDING_CHANGE_TYPE,
                    kind: PROPERTY_CHANGE_KIND,
                    changeType,
                    controlId: selectorId,
                    propertyType: PropertyType.ControlProperty,
                    propertyName: command.getProperty('propertyName'),
                    isActive: index >= inactiveCommandCount,
                    value,
                    controlName: command.getElement().getMetadata().getName().split('.').pop() ?? '',
                    fileName
                };
            } else if (changeType === 'appdescr_fe_changePageConfiguration') {
                const value = command.getProperty('parameters').entityPropertyChange.propertyValue;
                return this.prepareV4ConfigurationChange(command, value, fileName, index, inactiveCommandCount);
            } else if (changeType === 'appdescr_ui_generic_app_changePageConfiguration') {
                return this.prepareV2ConfigurationChange(command, fileName, index, inactiveCommandCount);
            } else {
                const title = TITLE_MAP[changeType] ?? '';
                let result = {
                    type: PENDING_CHANGE_TYPE,
                    kind: UNKNOWN_CHANGE_KIND,
                    ...title && { title },
                    changeType,
                    isActive: index >= inactiveCommandCount,
                    fileName
                };
                if (selectorId) {
                    result = {
                        ...result,
                        kind: 'control',
                        controlId: selectorId
                    };
                }
                return result;
            }
        }
        retryOperations(operations) {
            for (const operation of operations) {
                try {
                    const result = operation();
                    if (!result) {
                        continue;
                    }
                    return result;
                } catch (error) {
                    continue;
                }
            }
            Log.error('All retry operations failed');
            return undefined;
        }
        getCommandChangeType(command) {
            return this.retryOperations([
                () => command.getChangeType(),
                () => command.getPreparedChange().getDefinition().changeType
            ]);
        }
        getCommandSelectorId(command) {
            return this.retryOperations([
                () => command.getSelector().id,
                () => command.getElement().getProperty('persistencyKey'),
                () => command.getElement().getId(),
                () => command.getParent()?.getElement().getId()
            ]);
        }
        async getControlIdByChange(change) {
            const appComponent = this.options.rta.getRootControlInstance();
            const selector = typeof change.getSelector === 'function' ? change.getSelector() : undefined;
            const changeType = change.getChangeType();
            const layer = change.getLayer();
            if (!selector?.id) {
                return;
            }
            try {
                let control = JsControlTreeModifier.bySelector(selector, appComponent);
                if (!control) {
                    return selector.id;
                }
                const changeHandlerAPI = (await __ui5_require_async('sap/ui/fl/write/api/ChangesWriteAPI')).default;
                if (typeof changeHandlerAPI?.getChangeHandler !== 'function') {
                    return selector.id;
                }
                const changeHandler = await changeHandlerAPI.getChangeHandler({
                    changeType,
                    element: control,
                    modifier: JsControlTreeModifier,
                    layer
                });
                if (changeHandler && typeof changeHandler.getChangeVisualizationInfo === 'function') {
                    const result = await changeHandler.getChangeVisualizationInfo(change, appComponent);
                    return JsControlTreeModifier.getControlIdBySelector(result?.affectedControls?.[0] ?? selector, appComponent);
                }
                return JsControlTreeModifier.getControlIdBySelector(selector, appComponent);
            } catch (error) {
                Log.error('Getting element ID from change has failed:', getError(error));
                return selector.id;
            }
        }
        async syncOutlineChanges() {
            for (const change of this.savedChanges) {
                if (change.kind !== 'unknown' && change.kind !== 'configuration') {
                    const flexObject = await this.getFlexObject(this.changedFiles[change.fileName]);
                    change.controlId = await this.getControlIdByChange(flexObject) ?? '';
                }
            }
            this.updateStack();
        }
        onStackChange(handler) {
            this.addEventListener(STACK_CHANGE_EVENT, handler);
        }
        async getFlexObject(change) {
            if (isLowerThanMinimalUi5Version(await getUi5Version(), {
                    major: 1,
                    minor: 109
                })) {
                const Change = (await __ui5_require_async('sap/ui/fl/Change')).default;
                return new Change(change);
            }
            const FlexObjectFactory = (await __ui5_require_async('sap/ui/fl/apply/_internal/flexObjects/FlexObjectFactory')).default;
            return FlexObjectFactory.createFromFileContent(change);
        }
    }
    var __exports = { __esModule: true };
    __exports.STACK_CHANGE_EVENT = STACK_CHANGE_EVENT;
    __exports.ChangeService = ChangeService;
    return __exports;
});