"use strict";

sap.ui.define(["sap/ui/core/Fragment", "../i18n", "./controllers/AddFragment.controller", "./controllers/AddTableColumnFragments.controller", "./controllers/ControllerExtension.controller", "./controllers/ExtensionPoint.controller", "./controllers/FileExistsDialog.controller"], function (Fragment, ___i18n, __AddFragment, __AddTableColumnFragments, __ControllerExtension, __ExtensionPoint, __FileExistsDialog) {
  "use strict";

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule && typeof obj.default !== "undefined" ? obj.default : obj;
  }
  const getTextBundle = ___i18n["getTextBundle"];
  const AddFragment = _interopRequireDefault(__AddFragment);
  const AddTableColumnFragments = _interopRequireDefault(__AddTableColumnFragments);
  const ControllerExtension = _interopRequireDefault(__ControllerExtension);
  const ExtensionPoint = _interopRequireDefault(__ExtensionPoint);
  const FileExistsDialog = _interopRequireDefault(__FileExistsDialog);
  var DialogNames = /*#__PURE__*/function (DialogNames) {
    DialogNames["ADD_FRAGMENT"] = "AddFragment";
    DialogNames["ADD_TABLE_COLUMN_FRAGMENTS"] = "AddTableColumnFragments";
    DialogNames["CONTROLLER_EXTENSION"] = "ControllerExtension";
    DialogNames["ADD_FRAGMENT_AT_EXTENSION_POINT"] = "ExtensionPoint";
    DialogNames["FILE_EXISTS"] = "FileExistsDialog";
    return DialogNames;
  }(DialogNames || {});
  const OPEN_DIALOG_STATUS_CHANGED = 'OPEN_DIALOG_STATUS_CHANGED';
  class DialogFactory {
    static eventTarget = new EventTarget();
    static isDialogOpen = false;
    /**
     * Only one dialog can be open at a time. This flag indicates if a new dialog can be opened.
     */

    static get canOpenDialog() {
      return !this.isDialogOpen;
    }

    /**
     * Factory method for creating a new dialog.
     *
     * @param overlay - Control overlay.
     * @param rta - Runtime Authoring instance.
     * @param dialogName - Dialog name.
     * @param extensionPointData - Control ID.
     * @param options - Dialog options.
     */
    static async createDialog(overlay, rta, dialogName, extensionPointData) {
      let options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};
      if (this.isDialogOpen) {
        return;
      }
      let controller;
      const resources = await getTextBundle();
      switch (dialogName) {
        case DialogNames.ADD_FRAGMENT:
          controller = new AddFragment(`open.ux.preview.client.adp.controllers.${dialogName}`, overlay, rta, {
            ...('aggregation' in options && {
              aggregation: options.aggregation
            }),
            ...('defaultAggregationArrayIndex' in options && {
              defaultAggregationArrayIndex: options.defaultAggregationArrayIndex
            }),
            title: resources.getText(options.title ?? 'ADP_ADD_FRAGMENT_DIALOG_TITLE')
          });
          break;
        case DialogNames.ADD_TABLE_COLUMN_FRAGMENTS:
          controller = new AddTableColumnFragments(`open.ux.preview.client.adp.controllers.${dialogName}`, overlay, rta, {
            ...('aggregation' in options && {
              aggregation: options.aggregation
            }),
            title: resources.getText(options.title ?? 'ADP_ADD_FRAGMENT_DIALOG_TITLE')
          });
          break;
        case DialogNames.CONTROLLER_EXTENSION:
          controller = new ControllerExtension(`open.ux.preview.client.adp.controllers.${dialogName}`, overlay, rta);
          break;
        case DialogNames.ADD_FRAGMENT_AT_EXTENSION_POINT:
          controller = new ExtensionPoint(`open.ux.preview.client.adp.controllers.${dialogName}`, overlay, rta, extensionPointData);
          break;
        case DialogNames.FILE_EXISTS:
          controller = new FileExistsDialog(`open.ux.preview.client.adp.controllers.${dialogName}`, options);
          break;
      }
      const id = dialogName === DialogNames.ADD_FRAGMENT_AT_EXTENSION_POINT ? `dialog--${dialogName}` : undefined;
      const dialog = await Fragment.load({
        name: `open.ux.preview.client.adp.ui.${dialogName}`,
        controller,
        id
      });
      this.isDialogOpen = true;
      dialog.attachBeforeClose(() => {
        this.updateStatus(false);
      });
      await controller.setup(dialog);
      this.updateStatus(true);
    }

    /**
     * Updates open dialog status.
     *
     * @param isDialogOpen Flag indicating if there is an open dialog.
     */
    static updateStatus(isDialogOpen) {
      this.isDialogOpen = isDialogOpen;
      const event = new CustomEvent(OPEN_DIALOG_STATUS_CHANGED);
      this.eventTarget.dispatchEvent(event);
    }

    /**
     * Attach event handler for OPEN_DIALOG_STATUS_CHANGED event.
     *
     * @param handler Event handler.
     * @returns Function that removes listener.
     */
    static onOpenDialogStatusChange(handler) {
      this.eventTarget.addEventListener(OPEN_DIALOG_STATUS_CHANGED, handler);
      return () => {
        this.eventTarget.removeEventListener(OPEN_DIALOG_STATUS_CHANGED, handler);
      };
    }
  }
  var __exports = {
    __esModule: true
  };
  __exports.DialogNames = DialogNames;
  __exports.OPEN_DIALOG_STATUS_CHANGED = OPEN_DIALOG_STATUS_CHANGED;
  __exports.DialogFactory = DialogFactory;
  return __exports;
});
//# sourceMappingURL=dialog-factory.js.map