"use strict";

sap.ui.define(["sap/ui/core/library", "sap/ui/core/mvc/Controller", "sap/m/MessageToast", "../utils", "../../utils/error", "../../utils/core", "../control-utils", "sap/ui/dt/OverlayRegistry"], function (sap_ui_core_library, Controller, MessageToast, ___utils, ____utils_error, ____utils_core, __ControlUtils, OverlayRegistry) {
  "use strict";

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule && typeof obj.default !== "undefined" ? obj.default : obj;
  }
  const ValueState = sap_ui_core_library["ValueState"];
  const matchesFragmentName = ___utils["matchesFragmentName"];
  const getError = ____utils_error["getError"];
  const getControlById = ____utils_core["getControlById"];
  const ControlUtils = _interopRequireDefault(__ControlUtils);
  /**
   * @namespace open.ux.preview.client.adp.controllers
   */
  const BaseDialog = Controller.extend("open.ux.preview.client.adp.controllers.BaseDialog", {
    /**
     * Method is used in add fragment dialog controllers to get current control metadata which are needed on the dialog
     * @returns control metadata and target aggregations
     */
    getControlMetadata: function _getControlMetadata() {
      const selectorId = this.overlays.getId();
      let controlMetadata;
      const overlayControl = getControlById(selectorId);
      if (overlayControl) {
        this.runtimeControl = ControlUtils.getRuntimeControl(overlayControl);
        controlMetadata = this.runtimeControl.getMetadata();
      } else {
        throw new Error('Cannot get overlay control');
      }
      const allAggregations = Object.keys(controlMetadata.getAllAggregations());
      const hiddenAggregations = ['customData', 'layoutData', 'dependents'];
      const targetAggregation = allAggregations.filter(item => {
        if (hiddenAggregations.indexOf(item) === -1) {
          return item;
        }
        return false;
      });
      return {
        controlMetadata,
        targetAggregation
      };
    },
    /**
     * Fills indexArray from selected control children
     *
     * @param selectedControlChildren Array of numbers
     * @returns Array of key value pairs
     */
    fillIndexArray: function _fillIndexArray(selectedControlChildren) {
      let indexArray = [];
      if (selectedControlChildren.length === 0) {
        indexArray.push({
          key: 0,
          value: 0
        });
      } else {
        indexArray = selectedControlChildren.map((elem, index) => {
          return {
            key: index + 1,
            value: elem + 1
          };
        });
        indexArray.unshift({
          key: 0,
          value: 0
        });
        indexArray.push({
          key: selectedControlChildren.length + 1,
          value: selectedControlChildren.length + 1
        });
      }
      return indexArray;
    },
    /**
     * Handles fragment name input change
     *
     * @param event Event
     */
    onFragmentNameInputChange: function _onFragmentNameInputChange(event) {
      const input = event.getSource();
      const beginBtn = this.dialog.getBeginButton();
      const fragmentName = input.getValue();
      const fragmentList = this.model.getProperty('/fragmentList');
      const updateDialogState = function (valueState) {
        let valueStateText = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
        input.setValueState(valueState).setValueStateText(valueStateText);
        beginBtn.setEnabled(valueState === ValueState.Success);
      };
      if (fragmentName.length <= 0) {
        updateDialogState(ValueState.None);
        this.model.setProperty('/newFragmentName', null);
        return;
      }
      const fileExists = fragmentList.some(f => f.fragmentName === `${fragmentName}.fragment.xml`);
      if (fileExists) {
        updateDialogState(ValueState.Error, 'Enter a different name. The fragment name that you entered already exists in your project.');
        return;
      }
      const isValidName = /^[a-zA-Z_][a-zA-Z0-9_-]*$/.test(fragmentName);
      if (!isValidName) {
        updateDialogState(ValueState.Error, 'The fragment name cannot contain white spaces or special characters.');
        return;
      }
      if (fragmentName.length > 64) {
        updateDialogState(ValueState.Error, 'A fragment file name cannot contain more than 64 characters.');
        return;
      }
      const changeExists = this.checkForExistingChange(fragmentName);
      if (changeExists) {
        updateDialogState(ValueState.Error, 'Enter a different name. The fragment name entered matches the name of an unsaved fragment.');
        return;
      }
      updateDialogState(ValueState.Success);
      this.model.setProperty('/newFragmentName', fragmentName);
    },
    /**
     * Checks for the existence of a change associated with a specific fragment name in the RTA command stack.
     *
     * @param {string} fragmentName - The name of the fragment to check for existing changes.
     * @returns {Promise<boolean>} A promise that resolves to `true` if a matching change is found, otherwise `false`.
     */
    checkForExistingChange: function _checkForExistingChange(fragmentName) {
      const allCommands = this.rta.getCommandStack().getCommands();
      return allCommands.some(command => {
        if (typeof command.getCommands === 'function') {
          const addXmlCommand = command.getCommands().find(c => c?.getProperty('name') === 'addXMLAtExtensionPoint');
          return addXmlCommand && matchesFragmentName(addXmlCommand, fragmentName);
        } else {
          return matchesFragmentName(command, fragmentName);
        }
      });
    },
    /**
     * Sets custom function that fires when user presses escape key.
     */
    setEscapeHandler: function _setEscapeHandler() {
      this.dialog.setEscapeHandler(_ref => {
        let {
          resolve
        } = _ref;
        this.handleDialogClose();
        resolve();
      });
    },
    /**
     * Handles the dialog closing and destruction of it.
     */
    handleDialogClose: function _handleDialogClose() {
      this.dialog.close();
      this.dialog.destroy();
    },
    /**
     * Function that handles runtime thrown errors with MessageToast
     *
     * @param e error instance
     * @throws {Error}.
     */
    handleError: function _handleError(e) {
      const error = getError(e);
      MessageToast.show(error.message, {
        duration: 5000
      });
      throw error;
    },
    /**
     * Handles the index field whenever a specific aggregation is chosen
     *
     * @param specialIndexAggregation string | number
     */
    specialIndexHandling: function _specialIndexHandling(specialIndexAggregation) {
      const overlay = OverlayRegistry.getOverlay(this.runtimeControl);
      const aggregations = overlay.getDesignTimeMetadata().getData().aggregations;
      if (specialIndexAggregation in aggregations && 'specialIndexHandling' in aggregations[specialIndexAggregation]) {
        const controlType = this.runtimeControl.getMetadata().getName();
        this.model.setProperty('/indexHandlingFlag', false);
        this.model.setProperty('/specialIndexHandlingIcon', true);
        this.model.setProperty('/iconTooltip', `Index is defined by special logic of ${controlType} and can't be set here`);
      } else {
        this.model.setProperty('/indexHandlingFlag', true);
        this.model.setProperty('/specialIndexHandlingIcon', false);
        this.model.setProperty('/specialIndexHandlingIconPressed', false);
      }
    }
  });
  return BaseDialog;
});
//# sourceMappingURL=BaseDialog.controller.js.map