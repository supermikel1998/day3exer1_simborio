"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getVariant = getVariant;
exports.updateVariant = updateVariant;
exports.flpConfigurationExists = flpConfigurationExists;
exports.getAdpConfig = getAdpConfig;
exports.getWebappFiles = getWebappFiles;
const fs_1 = require("fs");
const path_1 = require("path");
const ui5_config_1 = require("@sap-ux/ui5-config");
/**
 * Get the app descriptor variant.
 *
 * @param {string} basePath - The path to the adaptation project.
 * @returns {DescriptorVariant} The app descriptor variant.
 */
function getVariant(basePath) {
    return JSON.parse((0, fs_1.readFileSync)((0, path_1.join)(basePath, 'webapp', 'manifest.appdescr_variant'), 'utf-8'));
}
/**
 * Writes the updated variant content to the manifest.appdescr_variant file.
 *
 * @param {string} basePath - The base path of the project.
 * @param {DescriptorVariant} variant - The descriptor variant object.
 * @param {Editor} fs - The mem-fs editor instance.
 */
function updateVariant(basePath, variant, fs) {
    fs.writeJSON((0, path_1.join)(basePath, 'webapp', 'manifest.appdescr_variant'), variant);
}
/**
 * Checks if FLP configuration changes exist in the manifest.appdescr_variant.
 *
 * This function determines whether there are changes of type `appdescr_app_changeInbound`
 * or `appdescr_app_addNewInbound` present in the content of the descriptor variant.
 *
 * @param {string} basePath - The base path of the project where the manifest.appdescr_variant is located.
 * @returns {boolean} Returns `true` if FLP configuration changes exist, otherwise `false`.
 * @throws {Error} Throws an error if the variant could not be retrieved.
 */
function flpConfigurationExists(basePath) {
    try {
        const variant = getVariant(basePath);
        return variant.content?.some(({ changeType }) => changeType === 'appdescr_app_changeInbound' || changeType === 'appdescr_app_addNewInbound');
    }
    catch (error) {
        throw new Error(`Failed to check if FLP configuration exists: ${error.message}`);
    }
}
/**
 * Returns the adaptation project configuration, throws an error if not found.
 *
 * @param {string} basePath - The path to the adaptation project.
 * @param {string} yamlPath - The path to yaml configuration file.
 * @returns {Promise<AdpPreviewConfig>} the adp configuration
 */
async function getAdpConfig(basePath, yamlPath) {
    const ui5ConfigPath = (0, path_1.isAbsolute)(yamlPath) ? yamlPath : (0, path_1.join)(basePath, yamlPath);
    const ui5Conf = await ui5_config_1.UI5Config.newInstance((0, fs_1.readFileSync)(ui5ConfigPath, 'utf-8'));
    const customMiddlerware = ui5Conf.findCustomMiddleware('fiori-tools-preview') ??
        ui5Conf.findCustomMiddleware('preview-middleware');
    const adp = customMiddlerware?.configuration?.adp;
    if (!adp) {
        throw new Error('No system configuration found in ui5.yaml');
    }
    return adp;
}
/**
 * Get all files in the webapp folder.
 *
 * @param {string} basePath - The path to the adaptation project.
 * @returns {Array<{ relativePath: string; content: string }>} The files in the webapp folder.
 */
function getWebappFiles(basePath) {
    const dir = (0, path_1.join)(basePath, 'webapp');
    const files = [];
    const getFilesRecursivelySync = (directory) => {
        const dirents = (0, fs_1.readdirSync)(directory, { withFileTypes: true });
        for (const dirent of dirents) {
            const fullPath = (0, path_1.join)(directory, dirent.name);
            if (dirent.isFile()) {
                const content = (0, fs_1.readFileSync)(fullPath, 'utf-8');
                const relativePath = (0, path_1.relative)(dir, fullPath);
                files.push({ relativePath, content });
            }
            else if (dirent.isDirectory()) {
                getFilesRecursivelySync(fullPath);
            }
        }
    };
    getFilesRecursivelySync(dir);
    return files;
}
//# sourceMappingURL=helper.js.map